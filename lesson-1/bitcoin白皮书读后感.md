# bitcoin白皮书读后感
## 摘要
* 目的：在线支付可以直接点对点不通过金融机构进行。
* 问题：数字签名外，我们还需要不依赖第三方来解决双花问题的解决方案。
* 方法：把带有网络时间戳的交易进行hash，将其hash值放入基于pow不断增长的链中，只有重做pow才可以修改记录。
* 补丁1，分叉：最长链不仅是见证事件顺序的证明，而且是最强算力的证明。
* 安全：当主要算力由诚实节点控制时，他们将生成最长链超过攻击者。
* 自由：节点可以自由加入或离开网络，以最长链作为证明。

## 1. 介绍
* 第三方电子支付困境：
> * 交易纠纷导致的回滚交易。
> * 调节交易纠纷带来的成本，限制了小额交易。引入回滚就导致信任蔓延，有了欺诈风险。
* bitcoin密码证明的优点：
> * 信任加密证明，而不是第三方。
> * 交易不可逆，保护卖方。实施常规托管机制保护买方。
> * 安全性，安全节点算力超过51%，就能保证系统的安全性。

## 2. 交易
* 交易链：owner0.sign(hash(上一个交易|收款人owner1公钥)
* 收款人owner1验证签名证明交易有效性。
* 问题：收款人无法验证所有者是否双花。
* 方法：引入授信的中央机构或矿工来检查双花。每一次交易矿工都铸造并返回新的币，只有矿工直接发行的币被认为是未双花的可信的币。整个金钱交易系统的命运依赖运行矿工的公司，每笔交易像银行一样都需要经过矿工完成。
> * 我们需要一种证明账户之前未签署过交易的方法。这要求所有交易公开，节点就单一订单历史达成一致；收款人需要每次交易时，大多数节点同意这是第一个被收到的证明。 
### 补充知识：签名
* 签名 sign(priKey, message) -> signMsg
> * 私钥加密消息的hash值后，追加在消息后面
* 验签 verify(pubKey, signMsg, message) -> (true|false)
> * 取消息后面签名，用公钥解密得到hash值，对比消息hash值和解密后得到的hash值是否一致，判断签名是否有效。

## 3. 时间戳服务
解决方案我们建议从时间戳服务开始，时间戳服务对要打时间戳的块条目进行hash，并在报纸或帖子中广播这个hash。时间戳证明，为了进入hash，数据当时必须已经存在。在hash中每一个时间戳要包含前一个时间戳，形成链，每个附加时间戳都会增强前一个。
> 创世块：The Times 03/Jan/2009 Chancellor on brink of second bailout for banks

## 4. 工作量证明
* 为了实现p2p的分布式时间服务，我们采用类似Adam Back的HashCash中的POW系统，而不是报纸或贴吧。
* POW：如用sha-256扫描计算hash，hash值以若干0位开始。达到若干0位要求的hash值计算工作是指数级的，但验证只需要一次hash计算。
* 对于我们的时间戳网络，POW实现方式：通过在区块中增加一个nonce值，矿工修改nonce值，不停尝试直到这个值被找到符合hash以若干0位开始的要求。
* 一旦计算出此nonce值，不重来一遍计算过程，将无法改变区块，当由区块链接在之后，更改这个区块中的内容就要更改接下来的所有区块内容。
* POW还解决了多数确定的投票问题，一个CPU一票。作恶节点需要修改区块及以后区块内容，同时出块领先诚实节点，随着后续块的增加，攻击者能追赶上的概率指数级下降。对硬件性能的提升或节点减少，出块难度会随每小时出块数目为目标进行移动。如果出块太快会增加难度。

## 5. 网络
* 运行网络步骤：
>* 新交易广播全部节点
>* 每个节点收集新交易到一个区块中
>* 每个节点为其块寻找满足要求的nonce
>* 找到nonce后，广播区块给所有节点
>* 节点接受区块的前提：区块中所有交易被验证且未被花费
>* 节点通过接受此区块的hash作为前一个区块的hash进行下一个区块的创建来表达对此区块的接受。

* 始终以最长链作为正确的链。如果某一时刻接收到不同的区块，在第一个接收到的上面继续工作，同时保留另外一个，以防他变得更长。当找到下一个nonce，且分支变得更长，关系将断开，在另一个分支上工作的节点将切换到更长的分支。
* 新交易广播不需要到达所有节点，只要到达一些节点，就很快进入一个块中。
* 区块广播容忍丢失消息，如果一个节点没有收到区块，在收到下一个区块时，并意识到丢失了区块会提出请求。

## 6. 激励
* 区块中第一笔交易固定为奖励区块生产者。
* 增加了节点支持网络的动力，同时提供币在没有中央授权情况下的发行到流通的方式。
* 稳定增加一定数量的新硬币，像黄金通过开采扩充其流动性一样。
* 我们这里消耗的是CPU计算时间和电力
* 激励也可以是交易费。如果交易输出小于交易输入，差额是交易费，包含在区块激励中。
* 当预定数量的币都进入流通后，激励就变成只有交易费，避免通货膨胀（通货紧缩型货币）。
* 激励鼓励节点保持诚实。
* 如果贪婪的攻击者聚集了超过诚实节点的CPU算力，他可能窃取他的付款来欺骗别人，或者生成新的货币。他应该发现，遵守规则更有利，这些规则恩惠他比任何人都多的新币，而不是破坏制度和自己财富的有效性。

## 7. 回收磁盘空间
轻量节点可以只保存区块链头（Merkle root），大小估计在80字节，按10分支出一个块的速度，一年区块链总计在4M左右。

## 8. 简单交易证明
* 轻量节点（只保留区块头）也可以验证交易，需要保证自己记录的是最长链的区块头，然后向全量节点获取交易位置其他分支hash,计算root hash和自己记录的进行对比，看是否一致，一致就表明交易在区块中，不一致表明交易不在区块中。
* 但是如果网络收到攻击者的压制，轻量节点验证就容易受到攻击。防止的方法是：当检测到无效块时会收到全量节点的报警，提示轻量节点用户下载全部区块并警告来确认不一致。收款频繁的企业希望运行自己的节点，以获取独立的安全性和快速的验证。

## 9. 合并和分割价值
* input 可以是单笔或多笔聚合
* output 至多两笔，一笔支付，一笔找零。
* 扇出（fan-out）一个交易依赖多个交易，那些交易又依赖更多的交易，这不存在问题，永远不需要提取交易历史记录的完整独立副本。（现在又单独的公司对交易进行追踪，btc交易已经可以监管）

## 10. 隐私
* 交易公开，但公钥匿名，你只能看到交易，但无法关联公钥对应的实体身份。像证券交易一样，能看到交易，但看不到交易双方。
* 额外保护：交易输出使用新的公私钥对。
* 风险：一笔交易有多个输入时，这些输入可以被认为是同一人。如果身份泄露，就会暴露这个身份相关的其他交易。

## 11. 计算
* 攻击者控制最长链时，无法凭空生成币，只能修改自己相关的交易，如果修改其他人的交易，诚实节点会判定区块无效，并不会跟随，就会形成分叉。
* 为防止“修改自己的交易”的攻击，确认交易需要等待区块的个数，和攻击者出块概率及诚实节点出块概率相关。从给的计算概率来看，攻击者出块概率越大，确认交易需要等待的块越多。
* 攻击者以强大的算力进行攻击，从经济收益角度看，就得不偿失了。

## 12. 总结
* 签名，确定所有权
* pow，完成公共历史记录
* 诚实节点控制大部分算力时，攻击很难进行
* 系统自动运行，不需要协调
* 节点可以自由出入
* cpu投票：通过生成新块来承若历史块，拒绝在某个分支后出块来拒绝无效块
* 激励和规则在共识机制下运行

## 读后感
* 按金本位创建了数字黄金
* 所有权问题：数字签名，但有双花问题。
* 双花问题：提出已使用的币和未使用的币，需要共识。后面公链都采用交易nonce来解决双花问题
* 共识问题：世界时间戳，没有选择报纸、贴吧，而是引入了pow共识，解决了“流通问题”、“通胀问题”、“持续激励问题”、“安全问题”
* 流通问题：出块时奖励约定数量的币，进入流通，最终将2100万个币全部流通
* 通胀问题：像黄金一样，有总量控制，防止通胀，通缩型，有利于早期快速发展，但发展到一定阶段后，新韭菜并不买单
* 持续性激励：出块激励，包括约定奖励币和交易打包小费
* 安全性：概率一致性，无最终一致性，安全由经济模型主导，如果不考虑经济成本，就没有安全可言
* 存储成本问题：提出轻量节点，但还是会持续增长。有项目通过零知识证明可以控制存储大小
* 隐私：一次一密，可以很好的避免身份被关联，但也可以做大概的分析，如果变现等和现实身份关联，依然可以追踪到，只是难度大了些。
* 将多种技术聚合在一起，开辟了一片新的领域。